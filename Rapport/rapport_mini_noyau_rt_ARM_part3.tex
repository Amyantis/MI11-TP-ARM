\begin{abstract}
Des trucs
\end{abstract}

\section{Le dîner des philosophes}
Pour toi théophile ;)

\section{Communication par tubes}
Les tubes sont des moyens de communication entre deux tâches. Le tube est exclusivement réservé aux deux tâches indiquées lors de sa création.
Le tube est un canal de communication unidirectionnel. L'une des deux tâches peut écrire dans le tube tandis que l'autre tâche peut lire les données sur le tube.

\subsection{Structure de données}
La structure du tube ressemble à celle d'une FIFO circulaire. Plusieurs informations supplémentaires viennent cependant compléter la structure dont notamment les tâches propriétaires du tube et un booléen afin de savoir si une tâche est endormie sur le tube.
\lstinputlisting[language=C, caption="Structure du pipe", firstline=16, lastline=23]{../Distribuable//pipe.h}

\subsection{Lecture et écriture}
La FIFO circulaire est de taille fixe dans le noyau. Il se peut alors que la tâche qui écrit des données remplisse la file auquel cas elle s'endormira.
De la même manière, si la tâche qui lit les données n'a plus de données à lire, elle s'endormira jusqu'à ce que de nouvelles données soient à consommer.
C'est le pipe qui implémente les mécanismes qui endorment et réveillent les tâches.
\lstinputlisting[language=C, caption="Ecriture dans un tube", firstline=111, lastline=145]{../Distribuable//pipe.c}
Il est possible d'écrire plusieurs données dans le pipe lors du même appel à la fonction write. La fonction itérative copie les données une par une dans le pipe. Si le pipe est plein, la tâche s'endort. Si après une écriture, il s'avère que le lecteur est endormi sur le pipe, alors on le réveille.
La fonction de lecture des données fonctionne de manière analogue.
\lstinputlisting[language=C, caption="Ecriture dans un tube", firstline=75, lastline=109]{../Distribuable//pipe.c}